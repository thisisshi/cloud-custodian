name: 'Build and Publish Docker Image'
description: 'Build and Publish Docker Image'
inputs:
  custodian_image_var:
    description: 'env var name for custodian image'
    required: true
  repository:
    description: 'docker hub repository'
    required: true
    default: 'cloudcustodian'
  name:
    description: 'image name'
    required: true
  push:
    description: 'push image: true/false'
    required: true
    default: false
  poetry_version:
    description: "Poetry Version to use"
    default: "1.1.14"
  trivy_version:
    description: "trivy version to use"
    default: "0.5.4"
  platforms:
    description: "Platforms to build, e.g. linux/arm64,linux/amd64"
    default: "linux/amd64"
runs:
  using: "composite"
  steps:
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v1
    - name: Set up Docker Buildx
      id: buildx
      uses: docker/setup-buildx-action@v1
    - name: Set up Python 3.10
      uses: actions/setup-python@v2
      with:
        python-version: "3.10"

    # until we get read only credentials, we'll only login if we're pushing
    # note that we can hit rate limits on pulling though
    - name: Login to Docker Hub
      if: "${{ inputs.push == 'true' }}"
      uses: docker/login-action@v1
      with:
        username: ${{ env.HUB_USER }}
        password: ${{ env.HUB_TOKEN }}

    - name: Docker meta
      id: meta
      uses: docker/metadata-action@v3
      with:
        images: |
          ${{ inputs.repository }}/${{ inputs.name }}
        tags: |
          type=semver,pattern={raw}
          type=raw,value=latest
        sep-tags: ','

    # build a single platform image first in order to actually load the image from buildx
    # manifests are not supported yet
    # https://github.com/docker/buildx/issues/166
    # https://github.com/docker/buildx/issues/59
    - name: Build
      uses: docker/build-push-action@v3.1.1
      with:
        context: .
        build-args: |
          POETRY_VERSION=${{ inputs.poetry_version }}
        push: false
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        # makes the image available in docker, e.g. docker images inspect
        load: true
        file: "docker/${{ inputs.name }}"

    - name: scan
      shell: bash
      env:
        tags: ${{ steps.meta.outputs.tags }}
      run: |
        mkdir -p bin
        wget -q -O bin/trivy.tgz https://github.com/aquasecurity/trivy/releases/download/v${{ inputs.trivy_version }}/trivy_${{ inputs.trivy_version }}_Linux-64bit.tar.gz
        cd bin && tar xzf trivy.tgz
        ./trivy $(echo $tags | cut -d ',' -f 1)
        cd ..

    - name: test
      shell: bash
      env:
        tags: ${{ steps.meta.outputs.tags }}
      run : |
        curl -sL https://raw.githubusercontent.com/python-poetry/poetry/master/install-poetry.py | python - -y --version ${{ inputs.poetry_version }}

        image_var=${{inputs.name}}
        image_var=CUSTODIAN_${image_var//[-]/_}_IMAGE
        image_var=${image_var^^}
        export ${image_var}="$(echo $tags | cut -d ',' -f 1)"

        python -m venv .
        . bin/activate && poetry install
        . bin/activate && pip install docker
        . bin/activate && TEST_DOCKER=yes \
                          pytest -p no:terraform -v tests/test_docker.py

    # actually push the multi arch image
    - name: Push
      if: "${{ inputs.push == 'true' }}"
      uses: docker/build-push-action@v3.1.1
      with:
        context: .
        build-args: |
          POETRY_VERSION=${{ inputs.poetry_version }}
        push: true
        platforms: ${{ inputs.platforms }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        file: "docker/${{ inputs.name }}"
